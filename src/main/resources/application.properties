# Imports variables from .env in root?
spring.config.import=optional:file:.env[.properties]

# Docker environment configuration
spring.application.name=trueshotodds
server.port=8080

#AWS RDS DB
spring.datasource.url=jdbc:mysql://${RDS_HOSTNAME}:${RDS_PORT}/${RDS_DB_NAME}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=false
spring.jpa.properties.hibernate.use_sql_comments=false
# Disable JPA Open-in-View pattern for better performance and explicit transaction boundaries
spring.jpa.open-in-view=false
spring.data.jpa.repositories.enabled=true

# Redis Configuration for Docker
spring.data.redis.host=${SPRING_REDIS_HOST}
spring.data.redis.port=${SPRING_REDIS_PORT}
spring.data.redis.password=
spring.data.redis.database=0
spring.data.redis.timeout=2000ms
spring.data.redis.lettuce.pool.max-active=8
spring.data.redis.lettuce.pool.max-idle=8
spring.data.redis.lettuce.pool.min-idle=0
spring.data.redis.lettuce.pool.max-wait=-1ms
spring.data.redis.repositories.enabled=false

# Spring Session Configuration
spring.session.store-type=redis
spring.session.redis.flush-mode=on-save
spring.session.redis.namespace=spring:session
spring.session.timeout=1800s
spring.session.redis.cleanup-cron=0 * * * * *

# Security Configuration for Docker
server.servlet.session.cookie.name=JSESSIONID
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.secure=false
server.servlet.session.cookie.same-site=lax
server.servlet.session.timeout=30m
server.servlet.session.tracking-modes=cookie

# Hikari Connection Pool Configuration
server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=30s

# Increase connection pool size for WebSocket usage
spring.datasource.hikari.maximum-pool-size=30
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=1200000
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.leak-detection-threshold=60000
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.validation-timeout=5000

# Mail Configuration
spring.mail.host=${MAIL_HOST}
spring.mail.port=${MAIL_PORT}
spring.mail.username=${MAIL_USERNAME}
spring.mail.password=${MAIL_PASSWORD}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.ssl.trust=smtp.gmail.com

# Logging Configuration for Docker
logging.level.dev.wenslo.trueshotodds=INFO
logging.level.org.springframework.security=WARN
logging.level.org.springframework.session=WARN
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=WARN
# Suppress intentional Spring Security AuthenticationProvider configuration warning
logging.level.org.springframework.security.config.annotation.authentication.configuration.InitializeUserDetailsBeanManagerConfigurer=ERROR
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# Actuator Configuration
management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.show-details=when-authorized
management.info.env.enabled=true
management.endpoint.health.probes.enabled=true
management.health.livenessstate.enabled=true
management.health.readinessstate.enabled=true

# OpenAPI Documentation
springdoc.api-docs.enabled=false
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method

# Custom Application Properties
app.security.password-reset-token-expiration-hours=1
app.security.max-failed-login-attempts=5
app.security.account-lockout-minutes=15
app.mail.from=${MAIL_FROM:noreply@trueshotodds.com}
app.mail.base-url=${BASE_URL:http://localhost:8080}

# CORS Configuration
app.cors.allowed-origins=${CORS_ALLOWED_ORIGINS:http://localhost:3000,http://localhost:3001,http://127.0.0.1:3000,http://127.0.0.1:3001}
app.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,PATCH
app.cors.allowed-headers=*
app.cors.allow-credentials=true
app.cors.max-age=3600

# Password Strength Configuration
app.security.password.min-length=8
app.security.password.max-length=128
app.security.password.require-uppercase=true
app.security.password.require-lowercase=true
app.security.password.require-digits=true
app.security.password.require-special-chars=false
app.security.password.min-special-chars=0
app.security.password.disallow-common-passwords=true

# Rate Limiting Configuration
app.security.rate-limit.enabled=true
app.security.rate-limit.login.requests-per-minute=5
app.security.rate-limit.registration.requests-per-minute=3
app.security.rate-limit.password-reset.requests-per-minute=2
app.security.rate-limit.resend-verification.requests-per-minute=2

# Google OAuth2 Configuration
spring.security.oauth2.client.registration.google.client-id=${GOOGLE_CLIENT_ID}
spring.security.oauth2.client.registration.google.client-secret=${GOOGLE_CLIENT_SECRET}
spring.security.oauth2.client.registration.google.scope=openid,profile,email
spring.security.oauth2.client.registration.google.redirect-uri={baseUrl}/login/oauth2/code/{registrationId}
spring.security.oauth2.client.provider.google.authorization-uri=https://accounts.google.com/o/oauth2/v2/auth
spring.security.oauth2.client.provider.google.token-uri=https://oauth2.googleapis.com/token
spring.security.oauth2.client.provider.google.user-info-uri=https://openidconnect.googleapis.com/v1/userinfo
spring.security.oauth2.client.provider.google.user-name-attribute=sub